/*Top View of Binary tree
Problem Description
Given a binary tree of integers denoted by root A. Return an array of integers representing the top view of the Binary tree.
The top view of a Binary Tree is a set of nodes visible when the tree is visited from the top.
Return the nodes in any order.
Problem Constraints
1 <= Number of nodes in binary tree <= 100000
0 <= node values <= 10^9
Input Format
First and only argument is head of the binary tree A.
Output Format
Return an array, representing the top view of the binary tree.

SC= O(N)
TC= O(N)
 */

package Trees;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Set;
import java.util.TreeMap;

public class TopViewOfBinaryTree {
    class Pair{
        TreeNode treeNode;
        int data;
        Pair(TreeNode t, int data){
            treeNode = t;
            this.data = data;
        }
    }
    public ArrayList<Integer> solve(TreeNode A) {

        if(A==null){
            return null;
        }

        LinkedList<Pair> queue = new LinkedList<>();

        TreeMap<Integer,ArrayList> resultMap = new TreeMap<>();

        ArrayList<ArrayList<Integer>> resultList = new ArrayList<>();

        queue.add(new Pair(A,0));

        TreeNode last = A;

        while(!queue.isEmpty()){
            ArrayList<Integer> list = null;
            Pair pairData = queue.remove();
            TreeNode node = pairData.treeNode;
            int x = pairData.data;
            if(node.left!=null){
                queue.add(new Pair(node.left,x-1));
            }
            if(node.right!=null){
                queue.add(new Pair(node.right,x+1));
            }
            if(node==last){
                Pair pData = queue.peekLast();
                TreeNode tNode = null;
                if(pData!=null){
                    tNode =  pData.treeNode;
                }
                if(tNode!=null){
                    last = tNode;
                }
            }

            if(resultMap.containsKey(pairData.data)){
                list = resultMap.get(pairData.data);
                list.add(node.val);
                resultMap.put(pairData.data,list);
            }else{
                list = new ArrayList<>();
                list.add(node.val);
                resultMap.put(pairData.data,list);
            }
        }

        Set<Integer> set1 =  resultMap.keySet();
        ArrayList<Integer> topViewNodes = new ArrayList<>();

        //Add the first element of result map generated by vertical ordering
        for(Integer key : set1){
            ArrayList list = resultMap.get(key);
            topViewNodes.add((int)list.get(0));
        }

        return topViewNodes;
    }
}

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */